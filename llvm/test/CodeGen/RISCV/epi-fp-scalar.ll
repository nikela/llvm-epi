; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv64 -mattr=+m,+f,+d,+a,+c,+experimental-v \
; RUN:    -target-abi lp64d -verify-machineinstrs < %s | FileCheck %s

; This test checks that in instructions with scalar float operands or return
; values, those are properly passed using a 64-bit FP regiter (no truncation).

define float @test_fp_ret_f32(<vscale x 2 x float> %a) nounwind {
; CHECK-LABEL: test_fp_ret_f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e32,m1,ta,mu
; CHECK-NEXT:    vfadd.vv v1, v16, v16
; CHECK-NEXT:    vfmv.f.s fa0, v1
; CHECK-NEXT:    # kill: def $f10_f killed $f10_f killed $f10_d
; CHECK-NEXT:    ret
  %add = fadd <vscale x 2 x float> %a, %a
  %first = call float @llvm.epi.vfmv.f.s.f32.nxv2f32(<vscale x 2 x float> %add)
  ret float %first
}

define double @test_fp_ret_f64(<vscale x 1 x double> %a) nounwind {
; CHECK-LABEL: test_fp_ret_f64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, zero, e64,m1,ta,mu
; CHECK-NEXT:    vfadd.vv v1, v16, v16
; CHECK-NEXT:    vfmv.f.s fa0, v1
; CHECK-NEXT:    ret
  %add = fadd <vscale x 1 x double> %a, %a
  %first = call double @llvm.epi.vfmv.f.s.f64.nxv1f64(<vscale x 1 x double> %add)
  ret double %first
}

define <vscale x 2 x float> @test_fp_op_f32(<vscale x 2 x float> %a, float %b, i64 %gvl) nounwind {
; CHECK-LABEL: test_fp_op_f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # kill: def $f10_f killed $f10_f def $f10_d
; CHECK-NEXT:    vsetvli a0, a0, e32,m1,ta,mu
; CHECK-NEXT:    vfadd.vf v16, v16, fa0
; CHECK-NEXT:    ret
  %add = call <vscale x 2 x float> @llvm.epi.vfadd.nxv2f32.f32(<vscale x 2 x float> %a, float %b, i64 %gvl)
  ret <vscale x 2 x float> %add
}

define <vscale x 1 x double> @test_fp_op_f64(<vscale x 1 x double> %a, double %b, i64 %gvl) nounwind {
; CHECK-LABEL: test_fp_op_f64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli a0, a0, e64,m1,ta,mu
; CHECK-NEXT:    vfadd.vf v16, v16, fa0
; CHECK-NEXT:    ret
  %add = call <vscale x 1 x double> @llvm.epi.vfadd.nxv1f64.f64(<vscale x 1 x double> %a, double %b, i64 %gvl)
  ret <vscale x 1 x double> %add
}

declare float @llvm.epi.vfmv.f.s.f32.nxv2f32(<vscale x 2 x float>)
declare double @llvm.epi.vfmv.f.s.f64.nxv1f64(<vscale x 1 x double>)
declare <vscale x 2 x float> @llvm.epi.vfadd.nxv2f32.f32(<vscale x 2 x float>, float, i64)
declare <vscale x 1 x double> @llvm.epi.vfadd.nxv1f64.f64(<vscale x 1 x double>, double, i64)
