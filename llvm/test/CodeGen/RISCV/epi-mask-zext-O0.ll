; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple riscv64 -mattr +m,+a,+f,+d,+experimental-v -o - \
; RUN:     --verify-machineinstrs -O0 %s | FileCheck %s

define <vscale x 8 x i1> @foo_O0(<vscale x 8 x i1> %a) nounwind noinline optnone {
; CHECK-LABEL: foo_O0:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addi sp, sp, -32
; CHECK-NEXT:    sd ra, 24(sp)
; CHECK-NEXT:    sd s0, 16(sp)
; CHECK-NEXT:    addi s0, sp, 32
; CHECK-NEXT:    rdvlenb a0
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    sd sp, -32(s0)
; CHECK-NEXT:    vsetvli a0, zero, e8,m1,tu,mu
; CHECK-NEXT:    ld a0, -32(s0)
; CHECK-NEXT:    vse8.v v0, (a0)
; CHECK-NEXT:    # implicit-def: $v0
; CHECK-NEXT:    vsetvli a0, zero, e8,m1,tu,mu
; CHECK-NEXT:    ld a0, -32(s0)
; CHECK-NEXT:    vle8.v v0, (a0)
; CHECK-NEXT:    addi sp, s0, -32
; CHECK-NEXT:    ld s0, 16(sp)
; CHECK-NEXT:    ld ra, 24(sp)
; CHECK-NEXT:    addi sp, sp, 32
; CHECK-NEXT:    ret
entry:
  %a.addr = alloca <vscale x 8 x i1>, align 1
  store <vscale x 8 x i1> %a, <vscale x 8 x i1>* %a.addr, align 1
  %0 = load <vscale x 8 x i1>, <vscale x 8 x i1>* %a.addr, align 1
  ret <vscale x 8 x i1> %0
}

define <vscale x 8 x i1> @foo(<vscale x 8 x i1> %a) nounwind {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addi sp, sp, -32
; CHECK-NEXT:    sd ra, 24(sp)
; CHECK-NEXT:    sd s0, 16(sp)
; CHECK-NEXT:    addi s0, sp, 32
; CHECK-NEXT:    rdvlenb a0
; CHECK-NEXT:    sub sp, sp, a0
; CHECK-NEXT:    sd sp, -32(s0)
; CHECK-NEXT:    vsetvli a0, zero, e8,m1,tu,mu
; CHECK-NEXT:    ld a0, -32(s0)
; CHECK-NEXT:    vse8.v v0, (a0)
; CHECK-NEXT:    addi sp, s0, -32
; CHECK-NEXT:    ld s0, 16(sp)
; CHECK-NEXT:    ld ra, 24(sp)
; CHECK-NEXT:    addi sp, sp, 32
; CHECK-NEXT:    ret
entry:
  %a.addr = alloca <vscale x 8 x i1>, align 1
  store <vscale x 8 x i1> %a, <vscale x 8 x i1>* %a.addr, align 1
  %0 = load <vscale x 8 x i1>, <vscale x 8 x i1>* %a.addr, align 1
  ret <vscale x 8 x i1> %0
}
