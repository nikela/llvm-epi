; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv64 -mattr=+m,+f,+d,+a,+c,+v,+zepi \
; RUN:    -verify-machineinstrs --riscv-no-aliases < %s | FileCheck %s

@scratch = global i8 0, align 16

declare <vscale x 1 x i64> @llvm.epi.vload.nxv1i64(
  <vscale x 1 x i64>*,
  i64);
declare void @llvm.epi.vstore.nxv1i64(
  <vscale x 1 x i64>,
  <vscale x 1 x i64>*,
  i64);

declare <vscale x 1 x i64> @llvm.epi.vload.nt.nxv1i64(
  <vscale x 1 x i64>*,
  i64);
declare void @llvm.epi.vstore.nt.nxv1i64(
  <vscale x 1 x i64>,
  <vscale x 1 x i64>*,
  i64);

declare <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
  <vscale x 1 x i64>*,
  i64, i64);
declare void @llvm.epi.vstore.ext.nxv1i64(
  <vscale x 1 x i64>,
  <vscale x 1 x i64>*,
  i64, i64);

define void @test.1(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ori a2, a2, 88
; CHECK-NEXT:    vsetvl zero, a3, a2
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    vs1r.v v8, (a1)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb, i64 %flags, i64 %gvl) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %flags, i64 %gvl)

  store <vscale x 1 x i64> %a, <vscale x 1 x i64>* %pb

  ret void
}

define void @test.2(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a3, e64, m1, ta, mu, nt
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    vs1r.v v8, (a1)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb, i64 %flags, i64 %gvl) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.nt.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %gvl)

  store <vscale x 1 x i64> %a, <vscale x 1 x i64>* %pb

  ret void
}

define void @test.3(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ori a2, a2, 88
; CHECK-NEXT:    vsetvl zero, a3, a2
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb, i64 %flags, i64 %gvl) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %flags, i64 %gvl)

  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb,
    i64 %flags, i64 %gvl)

  ret void
}

define void @test.4(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a3, e64, m1, ta, mu, nt
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb, i64 %flags, i64 %gvl) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.nt.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %gvl)

  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb,
    i64 %gvl)

  ret void
}

define void @test.5(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a3, e64, m1, ta, mu, nt
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    ori a0, a2, 88
; CHECK-NEXT:    vsetvl zero, a3, a0
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb, i64 %flags, i64 %gvl) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.nt.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %gvl)

  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb,
    i64 %flags, i64 %gvl)

  ret void
}

define void @test.6(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.6:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ori a2, a2, 88
; CHECK-NEXT:    vsetvl zero, a3, a2
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    vsetvli zero, zero, e64, m1, ta, mu, nt
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb, i64 %flags, i64 %gvl) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %flags, i64 %gvl)

  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb,
    i64 %gvl)

  ret void
}

define void @test.7(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.7:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a4, e64, m1, ta, mu, nt
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a5, 1
; CHECK-NEXT:    c.beqz a0, .LBB6_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.jr ra
; CHECK-NEXT:  .LBB6_2: # %else
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  i64 %flags, i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.nt.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %gvl)
  br label %exit

exit:
  ret void
}

define void @test.8(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ori a3, a3, 88
; CHECK-NEXT:    vsetvl zero, a4, a3
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a5, 1
; CHECK-NEXT:    c.beqz a0, .LBB7_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.jr ra
; CHECK-NEXT:  .LBB7_2: # %else
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  i64 %flags, i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %flags, i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %flags, i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %flags, i64 %gvl)
  br label %exit

exit:
  ret void
}


define void @test.9(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.9:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ori a3, a3, 88
; CHECK-NEXT:    vsetvl zero, a4, a3
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a5, 1
; CHECK-NEXT:    c.beqz a0, .LBB8_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    vsetvli zero, zero, e64, m1, ta, mu, nt
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.jr ra
; CHECK-NEXT:  .LBB8_2: # %else
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  i64 %flags, i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %flags, i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %flags, i64 %gvl)
  br label %exit

exit:
  ret void
}

define void @test.10(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.10:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a5, e64, m1, ta, mu, nt
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a6, 1
; CHECK-NEXT:    c.beqz a0, .LBB9_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
; CHECK-NEXT:  .LBB9_2: # %else
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  <vscale x 1 x i64> * %pb3,
  i64 %flags, i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.nt.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %gvl)
  br label %exit

exit:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb3,
    i64 %gvl)
  ret void
}

define void @test.11(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.11:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a5, e64, m1, ta, mu
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a6, 1
; CHECK-NEXT:    c.beqz a0, .LBB10_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.j .LBB10_3
; CHECK-NEXT:  .LBB10_2: # %else
; CHECK-NEXT:    vsetvli zero, zero, e64, m1, ta, mu, nt
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:  .LBB10_3: # %exit
; CHECK-NEXT:    vsetvli zero, zero, e64, m1, ta, mu
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  <vscale x 1 x i64> * %pb3,
  i64 %flags, i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %gvl)
  br label %exit

exit:
  call void @llvm.epi.vstore.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb3,
    i64 %gvl)
  ret void
}

define void @test.12(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.12:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsetvli zero, a5, e64, m1, ta, mu
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a6, 1
; CHECK-NEXT:    c.beqz a0, .LBB11_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    vsetvli zero, zero, e64, m1, ta, mu, nt
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
; CHECK-NEXT:  .LBB11_2: # %else
; CHECK-NEXT:    vsetvli zero, zero, e64, m1, ta, mu, nt
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  <vscale x 1 x i64> * %pb3,
  i64 %flags, i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %gvl)
  br label %exit

exit:
  call void @llvm.epi.vstore.nt.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb3,
    i64 %gvl)
  ret void
}

define void @test.13(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.13:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ori a4, a4, 88
; CHECK-NEXT:    vsetvl zero, a6, a4
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a7, 1
; CHECK-NEXT:    c.beqz a0, .LBB12_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    ori a0, a5, 88
; CHECK-NEXT:    vsetvl zero, a6, a0
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
; CHECK-NEXT:  .LBB12_2: # %else
; CHECK-NEXT:    ori a0, a5, 88
; CHECK-NEXT:    vsetvl zero, a6, a0
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  <vscale x 1 x i64> * %pb3,
  i64 %flags1, i64 %flags2,
  i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %flags1, i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %flags2, i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %flags2, i64 %gvl)
  br label %exit

exit:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb3,
    i64 %flags2, i64 %gvl)
  ret void
}

define void @test.14(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.14:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ori a4, a4, 88
; CHECK-NEXT:    vsetvl zero, a5, a4
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a6, 1
; CHECK-NEXT:    c.beqz a0, .LBB13_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
; CHECK-NEXT:  .LBB13_2: # %else
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  <vscale x 1 x i64> * %pb3,
  i64 %flags1,
  i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %flags1, i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %flags1, i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %flags1, i64 %gvl)
  br label %exit

exit:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb3,
    i64 %flags1, i64 %gvl)
  ret void
}

define void @test.15(<vscale x 1 x i64> * %pa,
; CHECK-LABEL: test.15:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ori t0, a4, 88
; CHECK-NEXT:    vsetvl zero, a6, t0
; CHECK-NEXT:    vle64.v v8, (a0)
; CHECK-NEXT:    andi a0, a7, 1
; CHECK-NEXT:    c.beqz a0, .LBB14_2
; CHECK-NEXT:  # %bb.1: # %then
; CHECK-NEXT:    ori a0, a5, 88
; CHECK-NEXT:    vsetvl zero, a6, a0
; CHECK-NEXT:    vse64.v v8, (a1)
; CHECK-NEXT:    c.j .LBB14_3
; CHECK-NEXT:  .LBB14_2: # %else
; CHECK-NEXT:    ori a0, a5, 88
; CHECK-NEXT:    vsetvl zero, a6, a0
; CHECK-NEXT:    vse64.v v8, (a2)
; CHECK-NEXT:  .LBB14_3: # %exit
; CHECK-NEXT:    ori a0, a4, 88
; CHECK-NEXT:    vsetvl zero, a6, a0
; CHECK-NEXT:    vse64.v v8, (a3)
; CHECK-NEXT:    c.jr ra
  <vscale x 1 x i64> * %pb1,
  <vscale x 1 x i64> * %pb2,
  <vscale x 1 x i64> * %pb3,
  i64 %flags1, i64 %flags2,
  i64 %gvl, i1 %cond) nounwind {
entry:
  %a = call <vscale x 1 x i64> @llvm.epi.vload.ext.nxv1i64(
    <vscale x 1 x i64>* %pa,
    i64 %flags1, i64 %gvl)
  br i1 %cond, label %then, label %else

then:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb1,
    i64 %flags2, i64 %gvl)
  br label %exit

else:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb2,
    i64 %flags2, i64 %gvl)
  br label %exit

exit:
  call void @llvm.epi.vstore.ext.nxv1i64(
    <vscale x 1 x i64> %a,
    <vscale x 1 x i64>* %pb3,
    i64 %flags1, i64 %gvl)
  ret void
}
