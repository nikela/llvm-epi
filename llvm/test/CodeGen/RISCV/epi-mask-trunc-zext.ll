; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple riscv64 -mattr +m,+a,+f,+d,+experimental-v -o - \
; RUN:     --verify-machineinstrs %s -epi-pipeline | FileCheck %s

; Note: Check epi-vp-logical.ll and epi-full-vector-logical.ll contain
; extensive LMUL>1 zext and trunc testcases.

define <vscale x 1 x i1> @mtrunc_1(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b, i64 %gvl) nounwind
; CHECK-LABEL: mtrunc_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli zero, a0, e64,m1,ta,mu
; CHECK-NEXT:    vand.vi v25, v8, 1
; CHECK-NEXT:    vmsne.vi v25, v25, 0
; CHECK-NEXT:    vand.vi v26, v9, 1
; CHECK-NEXT:    vmsne.vi v26, v26, 0
; CHECK-NEXT:    vmand.mm v0, v25, v26
; CHECK-NEXT:    ret
{
  %ma = trunc <vscale x 1 x i64> %a to <vscale x 1 x i1>
  %mb = trunc <vscale x 1 x i64> %b to <vscale x 1 x i1>

  %mc = call <vscale x 1 x i1> @llvm.epi.vmand.nxv1i1.nxv1i1(<vscale x 1 x i1> %ma, <vscale x 1 x i1> %mb, i64 %gvl)

  ret <vscale x 1 x i1> %mc
}

declare <vscale x 1 x i1> @llvm.epi.vmand.nxv1i1.nxv1i1(<vscale x 1 x i1> %a, <vscale x 1 x i1> %b, i64 %gvl)

define <vscale x 1 x i64> @mzext_1(<vscale x 1 x i1> %ma, <vscale x 1 x i1> %mb, i64 %gvl) nounwind
; CHECK-LABEL: mzext_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli zero, a0, e64,m1,ta,mu
; CHECK-NEXT:    vmv.v.i v25, 0
; CHECK-NEXT:    vmerge.vim v26, v25, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v25, v25, 1, v0
; CHECK-NEXT:    vand.vv v8, v26, v25
; CHECK-NEXT:    ret
{
  %a = zext <vscale x 1 x i1> %ma to <vscale x 1 x i64>
  %b = zext <vscale x 1 x i1> %mb to <vscale x 1 x i64>

  %c = call <vscale x 1 x i64> @llvm.epi.vand.nxv1i64.nxv1i64(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b, i64 %gvl)

  ret <vscale x 1 x i64> %c
}

declare <vscale x 1 x i64> @llvm.epi.vand.nxv1i64.nxv1i64(<vscale x 1 x i64> %a, <vscale x 1 x i64> %b, i64 %gvl)

define <vscale x 2 x i1> @mtrunc_2(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b, i64 %gvl) nounwind
; CHECK-LABEL: mtrunc_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli zero, a0, e32,m1,ta,mu
; CHECK-NEXT:    vand.vi v26, v8, 1
; CHECK-NEXT:    vmsne.vi v25, v26, 0
; CHECK-NEXT:    vand.vi v26, v10, 1
; CHECK-NEXT:    vmsne.vi v26, v26, 0
; CHECK-NEXT:    vmand.mm v0, v25, v26
; CHECK-NEXT:    ret
{
  %ma = trunc <vscale x 2 x i64> %a to <vscale x 2 x i1>
  %mb = trunc <vscale x 2 x i64> %b to <vscale x 2 x i1>

  %mc = call <vscale x 2 x i1> @llvm.epi.vmand.nxv2i1.nxv2i1(<vscale x 2 x i1> %ma, <vscale x 2 x i1> %mb, i64 %gvl)

  ret <vscale x 2 x i1> %mc
}

declare <vscale x 2 x i1> @llvm.epi.vmand.nxv2i1.nxv2i1(<vscale x 2 x i1> %a, <vscale x 2 x i1> %b, i64 %gvl)

define <vscale x 2 x i64> @mzext_2(<vscale x 2 x i1> %ma, <vscale x 2 x i1> %mb, i64 %gvl) nounwind
; CHECK-LABEL: mzext_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vsetvli zero, a0, e64,m2,ta,mu
; CHECK-NEXT:    vmv.v.i v26, 0
; CHECK-NEXT:    vmerge.vim v28, v26, 1, v0
; CHECK-NEXT:    vmv1r.v v0, v8
; CHECK-NEXT:    vmerge.vim v26, v26, 1, v0
; CHECK-NEXT:    vand.vv v8, v28, v26
; CHECK-NEXT:    ret
{
  %a = zext <vscale x 2 x i1> %ma to <vscale x 2 x i64>
  %b = zext <vscale x 2 x i1> %mb to <vscale x 2 x i64>

  %c = call <vscale x 2 x i64> @llvm.epi.vand.nxv2i64.nxv2i64(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b, i64 %gvl)

  ret <vscale x 2 x i64> %c
}

declare <vscale x 2 x i64> @llvm.epi.vand.nxv2i64.nxv2i64(<vscale x 2 x i64> %a, <vscale x 2 x i64> %b, i64 %gvl)
