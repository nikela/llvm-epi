; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv64 -mattr=+f,+v -verify-machineinstrs < %s | FileCheck %s

define void @myMatmul(i64 %N, ptr %A, ptr %B, ptr %C) {
; CHECK-LABEL: myMatmul:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    blez a0, .LBB0_3
; CHECK-NEXT:  # %bb.1: # %vector.ph
; CHECK-NEXT:    li a4, 0
; CHECK-NEXT:  .LBB0_2: # %vector.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sub a5, a0, a4
; CHECK-NEXT:    vsetvli a5, a5, e32, m1, ta, mu
; CHECK-NEXT:    flw ft0, 0(a1)
; CHECK-NEXT:    slli a6, a4, 2
; CHECK-NEXT:    add a7, a2, a6
; CHECK-NEXT:    vle32.v v8, (a7)
; CHECK-NEXT:    add a6, a3, a6
; CHECK-NEXT:    vle32.v v9, (a6)
; CHECK-NEXT:    vfmacc.vf v9, ft0, v8
; CHECK-NEXT:    add a4, a4, a5
; CHECK-NEXT:    vse32.v v9, (a6)
; CHECK-NEXT:    bne a4, a0, .LBB0_2
; CHECK-NEXT:  .LBB0_3: # %for.end
; CHECK-NEXT:    ret
entry:
  %cmp8 = icmp sgt i64 %N, 0
  br i1 %cmp8, label %vector.ph, label %for.end

vector.ph:
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %0 = sub i64 %N, %index
  %1 = tail call i64 @llvm.epi.vsetvl(i64 %0, i64 2, i64 0)
  %2 = trunc i64 %1 to i32
  %3 = insertelement <vscale x 2 x ptr> poison, ptr %A, i64 0
  %4 = shufflevector <vscale x 2 x ptr> %3, <vscale x 2 x ptr> poison, <vscale x 2 x i32> zeroinitializer
  %vp.gather = tail call <vscale x 2 x float> @llvm.vp.gather.nxv2f32.nxv2p0(<vscale x 2 x ptr> %4, <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i32 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer), i32 %2)
  %5 = getelementptr inbounds float, ptr %B, i64 %index
  %vp.op.load = tail call <vscale x 2 x float> @llvm.vp.load.nxv2f32.p0(ptr %5, <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i32 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer), i32 %2)
  %6 = getelementptr inbounds float, ptr %C, i64 %index
  %vp.op.load102 = tail call <vscale x 2 x float> @llvm.vp.load.nxv2f32.p0(ptr %6, <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i32 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer), i32 %2)
  %7 = tail call <vscale x 2 x float> @llvm.vp.fmuladd.nxv2f32(<vscale x 2 x float> %vp.gather, <vscale x 2 x float> %vp.op.load, <vscale x 2 x float> %vp.op.load102, <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i32 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer), i32 %2)
  tail call void @llvm.vp.store.nxv2f32.p0(<vscale x 2 x float> %7, ptr %6, <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i32 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer), i32 %2)
  %8 = and i64 %1, 4294967295
  %index.next = add i64 %index, %8
  %9 = icmp eq i64 %index.next, %N
  br i1 %9, label %for.end, label %vector.body

for.end:
  ret void
}

declare i64 @llvm.epi.vsetvl(i64, i64, i64)
declare <vscale x 2 x float> @llvm.vp.gather.nxv2f32.nxv2p0(<vscale x 2 x ptr>, <vscale x 2 x i1>, i32)
declare <vscale x 2 x float> @llvm.vp.load.nxv2f32.p0(ptr nocapture, <vscale x 2 x i1>, i32)
declare <vscale x 2 x float> @llvm.vp.fmuladd.nxv2f32(<vscale x 2 x float>, <vscale x 2 x float>, <vscale x 2 x float>, <vscale x 2 x i1>, i32)
declare void @llvm.vp.store.nxv2f32.p0(<vscale x 2 x float>, ptr nocapture, <vscale x 2 x i1>, i32)
