; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv64 -mattr=+m,+f,+d,+experimental-v -verify-machineinstrs -O0 \
; RUN:    < %s -epi-pipeline | FileCheck --check-prefix=SPILL-O0 %s
; RUN: llc -mtriple=riscv64 -mattr=+m,+f,+d,+experimental-v -verify-machineinstrs -O2 \
; RUN:    < %s -epi-pipeline | FileCheck --check-prefix=SPILL-O2 %s

define dso_local void @bar(double* nocapture %pa, double* nocapture readonly %pb, i64 %gvl) nounwind {
; SPILL-O0-LABEL: bar:
; SPILL-O0:       # %bb.0: # %entry
; SPILL-O0-NEXT:    addi sp, sp, -48
; SPILL-O0-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; SPILL-O0-NEXT:    csrr a3, vlenb
; SPILL-O0-NEXT:    slli a3, a3, 1
; SPILL-O0-NEXT:    sub sp, sp, a3
; SPILL-O0-NEXT:    sd a2, 24(sp) # 8-byte Folded Spill
; SPILL-O0-NEXT:    sd a0, 32(sp) # 8-byte Folded Spill
; SPILL-O0-NEXT:    # implicit-def: $v10
; SPILL-O0-NEXT:    vsetvli zero, a2, e64, m1, ta, mu
; SPILL-O0-NEXT:    vle64.v v10, (a0)
; SPILL-O0-NEXT:    # implicit-def: $v11
; SPILL-O0-NEXT:    vle64.v v11, (a1)
; SPILL-O0-NEXT:    # implicit-def: $v8_v9
; SPILL-O0-NEXT:    vzip2.vv v8, v10, v11
; SPILL-O0-NEXT:    vmv1r.v v10, v9
; SPILL-O0-NEXT:    csrr a0, vlenb
; SPILL-O0-NEXT:    add a0, sp, a0
; SPILL-O0-NEXT:    addi a0, a0, 40
; SPILL-O0-NEXT:    vs1r.v v10, (a0) # Unknown-size Folded Spill
; SPILL-O0-NEXT:    # kill: def $v8 killed $v8 killed $v8_v9
; SPILL-O0-NEXT:    addi a0, sp, 40
; SPILL-O0-NEXT:    vs1r.v v8, (a0) # Unknown-size Folded Spill
; SPILL-O0-NEXT:    call foo
; SPILL-O0-NEXT:    ld a2, 24(sp) # 8-byte Folded Reload
; SPILL-O0-NEXT:    addi a0, sp, 40
; SPILL-O0-NEXT:    vl1r.v v9, (a0) # Unknown-size Folded Reload
; SPILL-O0-NEXT:    ld a0, 32(sp) # 8-byte Folded Reload
; SPILL-O0-NEXT:    csrr a1, vlenb
; SPILL-O0-NEXT:    add a1, sp, a1
; SPILL-O0-NEXT:    addi a1, a1, 40
; SPILL-O0-NEXT:    vl1r.v v8, (a1) # Unknown-size Folded Reload
; SPILL-O0-NEXT:    vsetvli zero, a2, e64, m1, ta, mu
; SPILL-O0-NEXT:    vse64.v v9, (a0)
; SPILL-O0-NEXT:    vse64.v v8, (a0)
; SPILL-O0-NEXT:    csrr a0, vlenb
; SPILL-O0-NEXT:    slli a0, a0, 1
; SPILL-O0-NEXT:    add sp, sp, a0
; SPILL-O0-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; SPILL-O0-NEXT:    addi sp, sp, 48
; SPILL-O0-NEXT:    ret
;
; SPILL-O2-LABEL: bar:
; SPILL-O2:       # %bb.0: # %entry
; SPILL-O2-NEXT:    addi sp, sp, -48
; SPILL-O2-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; SPILL-O2-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; SPILL-O2-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; SPILL-O2-NEXT:    csrr a3, vlenb
; SPILL-O2-NEXT:    slli a3, a3, 1
; SPILL-O2-NEXT:    sub sp, sp, a3
; SPILL-O2-NEXT:    mv s0, a2
; SPILL-O2-NEXT:    mv s1, a0
; SPILL-O2-NEXT:    vsetvli zero, a2, e64, m1, ta, mu
; SPILL-O2-NEXT:    vle64.v v8, (a0)
; SPILL-O2-NEXT:    vle64.v v9, (a1)
; SPILL-O2-NEXT:    vzip2.vv v8, v8, v9
; SPILL-O2-NEXT:    addi a0, sp, 24
; SPILL-O2-NEXT:    csrr a1, vlenb
; SPILL-O2-NEXT:    vs1r.v v8, (a0) # Unknown-size Folded Spill
; SPILL-O2-NEXT:    add a0, a0, a1
; SPILL-O2-NEXT:    vs1r.v v9, (a0) # Unknown-size Folded Spill
; SPILL-O2-NEXT:    call foo
; SPILL-O2-NEXT:    vsetvli zero, s0, e64, m1, ta, mu
; SPILL-O2-NEXT:    addi a0, sp, 24
; SPILL-O2-NEXT:    csrr a1, vlenb
; SPILL-O2-NEXT:    vl1r.v v8, (a0) # Unknown-size Folded Reload
; SPILL-O2-NEXT:    add a0, a0, a1
; SPILL-O2-NEXT:    vl1r.v v9, (a0) # Unknown-size Folded Reload
; SPILL-O2-NEXT:    vse64.v v8, (s1)
; SPILL-O2-NEXT:    vse64.v v9, (s1)
; SPILL-O2-NEXT:    csrr a0, vlenb
; SPILL-O2-NEXT:    slli a0, a0, 1
; SPILL-O2-NEXT:    add sp, sp, a0
; SPILL-O2-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; SPILL-O2-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; SPILL-O2-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; SPILL-O2-NEXT:    addi sp, sp, 48
; SPILL-O2-NEXT:    ret
entry:
  %0 = bitcast double* %pa to <vscale x 1 x double>*
  %1 = tail call <vscale x 1 x double> @llvm.epi.vload.nxv1f64(<vscale x 1 x double>* %0, i64 %gvl)
  %2 = bitcast double* %pb to <vscale x 1 x double>*
  %3 = tail call <vscale x 1 x double> @llvm.epi.vload.nxv1f64(<vscale x 1 x double>* %2, i64 %gvl)
  %4 = tail call { <vscale x 1 x double>, <vscale x 1 x double> } @llvm.epi.vzip2.nxv1f64(<vscale x 1 x double> %1, <vscale x 1 x double> %3, i64 %gvl)
  %5 = extractvalue { <vscale x 1 x double>, <vscale x 1 x double> } %4, 0
  %6 = extractvalue { <vscale x 1 x double>, <vscale x 1 x double> } %4, 1
  tail call void @foo() #5
  tail call void @llvm.epi.vstore.nxv1f64(<vscale x 1 x double> %5, <vscale x 1 x double>* %0, i64 %gvl)
  tail call void @llvm.epi.vstore.nxv1f64(<vscale x 1 x double> %6, <vscale x 1 x double>* %0, i64 %gvl)
  ret void
}

declare <vscale x 1 x double> @llvm.epi.vload.nxv1f64(<vscale x 1 x double>* nocapture, i64)

declare { <vscale x 1 x double>, <vscale x 1 x double> } @llvm.epi.vzip2.nxv1f64(<vscale x 1 x double>, <vscale x 1 x double>, i64)

declare dso_local void @foo()

declare void @llvm.epi.vstore.nxv1f64(<vscale x 1 x double>, <vscale x 1 x double>* nocapture, i64)

