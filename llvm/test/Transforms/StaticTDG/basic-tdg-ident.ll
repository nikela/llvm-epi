; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -static-tdg-id < %s -S -o - | FileCheck %s
%struct.ident_t = type { i32, i32, i32, i32, i8* }
%struct.anon = type { i32* }
%struct.anon.0 = type {}
%struct.kmp_task_t_with_privates = type { %struct.kmp_task_t, %struct..kmp_privates.t }
%struct.kmp_task_t = type { i8*, i32 (i32, i8*)*, i32, %union.kmp_cmplrdata_t, %union.kmp_cmplrdata_t }
%union.kmp_cmplrdata_t = type { i32 (i32, i8*)* }
%struct..kmp_privates.t = type { i32 }

@0 = external hidden unnamed_addr constant %struct.ident_t, align 8
@__staticTaskID = external global i32, align 4

; Function Attrs: noinline nounwind optnone uwtable
define hidden void @__captured_stmt(%struct.anon* noalias %__context) {
; CHECK-LABEL: @__captured_stmt(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 0, i32* @__staticTaskID, align 4
; CHECK-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca %struct.anon*, align 8
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[AGG_CAPTURED:%.*]] = alloca [[STRUCT_ANON_0:%.*]], align 1
; CHECK-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_global_thread_num(%struct.ident_t* [[GLOB0:@.*]])
; CHECK-NEXT:    store %struct.anon* [[__CONTEXT:%.*]], %struct.anon** [[__CONTEXT_ADDR]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load %struct.anon*, %struct.anon** [[__CONTEXT_ADDR]], align 8
; CHECK-NEXT:    store i32 0, i32* [[I]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 0, i32* [[TMP2]], align 4
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32* [[TMP2]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    store i32 [[TMP4]], i32* [[TMP2]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32* [[I]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds [[STRUCT_ANON:%.*]], %struct.anon* [[TMP1]], i32 0, i32 0
; CHECK-NEXT:    [[TMP7:%.*]] = load i32*, i32** [[TMP6]], align 8
; CHECK-NEXT:    [[TMP8:%.*]] = load i32, i32* [[TMP7]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP5]], [[TMP8]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP9:%.*]] = call i8* @__kmpc_omp_task_alloc(%struct.ident_t* [[GLOB0]], i32 [[TMP0]], i32 1, i64 48, i64 0, i32 (i32, i8*)* bitcast (i32 (i32, %struct.kmp_task_t_with_privates*)* @.omp_task_entry. to i32 (i32, i8*)*))
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, i32* @__staticTaskID, align 4
; CHECK-NEXT:    [[TMP11:%.*]] = add i32 [[TMP10]], 1
; CHECK-NEXT:    store i32 [[TMP11]], i32* @__staticTaskID, align 4
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, i32* [[TMP2]], align 4
; CHECK-NEXT:    [[TMP13:%.*]] = add i32 [[TMP12]], 0
; CHECK-NEXT:    [[TMP14:%.*]] = mul i32 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = mul i32 [[TMP14]], 1
; CHECK-NEXT:    [[TMP16:%.*]] = add i32 [[TMP15]], 1
; CHECK-NEXT:    call void @__kmpc_set_task_static_id(i8* [[TMP9]], i32 [[TMP16]])
; CHECK-NEXT:    [[TMP17:%.*]] = bitcast i8* [[TMP9]] to %struct.kmp_task_t_with_privates*
; CHECK-NEXT:    [[TMP18:%.*]] = getelementptr inbounds [[STRUCT_KMP_TASK_T_WITH_PRIVATES:%.*]], %struct.kmp_task_t_with_privates* [[TMP17]], i32 0, i32 0
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr inbounds [[STRUCT_KMP_TASK_T_WITH_PRIVATES]], %struct.kmp_task_t_with_privates* [[TMP17]], i32 0, i32 1
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr inbounds [[STRUCT__KMP_PRIVATES_T:%.*]], %struct..kmp_privates.t* [[TMP19]], i32 0, i32 0
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, i32* [[I]], align 4
; CHECK-NEXT:    store i32 [[TMP21]], i32* [[TMP20]], align 8
; CHECK-NEXT:    [[TMP22:%.*]] = call i32 @__kmpc_omp_task(%struct.ident_t* [[GLOB0]], i32 [[TMP0]], i8* [[TMP9]])
; CHECK-NEXT:    br label [[FOR_INC:%.*]]
; CHECK:       for.inc:
; CHECK-NEXT:    [[TMP23:%.*]] = load i32, i32* [[I]], align 4
; CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP23]], 1
; CHECK-NEXT:    store i32 [[INC]], i32* [[I]], align 4
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end:
; CHECK-NEXT:    ret void
;
entry:
  store i32 0, i32* @__staticTaskID, align 4
  %__context.addr = alloca %struct.anon*, align 8
  %i = alloca i32, align 4
  %agg.captured = alloca %struct.anon.0, align 1
  %0 = call i32 @__kmpc_global_thread_num(%struct.ident_t* @0)
  store %struct.anon* %__context, %struct.anon** %__context.addr, align 8
  %1 = load %struct.anon*, %struct.anon** %__context.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = getelementptr inbounds %struct.anon, %struct.anon* %1, i32 0, i32 0
  %4 = load i32*, i32** %3, align 8
  %5 = load i32, i32* %4, align 4
  %cmp = icmp slt i32 %2, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = call i8* @__kmpc_omp_task_alloc(%struct.ident_t* @0, i32 %0, i32 1, i64 48, i64 0, i32 (i32, i8*)* bitcast (i32 (i32, %struct.kmp_task_t_with_privates*)* @.omp_task_entry. to i32 (i32, i8*)*))
  %7 = load i32, i32* @__staticTaskID, align 4
  %8 = add i32 %7, 1
  store i32 %8, i32* @__staticTaskID, align 4
  call void @__kmpc_set_task_static_id(i8* %6, i32 %8)
  %9 = bitcast i8* %6 to %struct.kmp_task_t_with_privates*
  %10 = getelementptr inbounds %struct.kmp_task_t_with_privates, %struct.kmp_task_t_with_privates* %9, i32 0, i32 0
  %11 = getelementptr inbounds %struct.kmp_task_t_with_privates, %struct.kmp_task_t_with_privates* %9, i32 0, i32 1
  %12 = getelementptr inbounds %struct..kmp_privates.t, %struct..kmp_privates.t* %11, i32 0, i32 0
  %13 = load i32, i32* %i, align 4
  store i32 %13, i32* %12, align 8
  %14 = call i32 @__kmpc_omp_task(%struct.ident_t* @0, i32 %0, i8* %6)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, i32* %i, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare hidden i32 @.omp_task_entry.(i32, %struct.kmp_task_t_with_privates* noalias)

declare i32 @__kmpc_global_thread_num(%struct.ident_t*)

declare i8* @__kmpc_omp_task_alloc(%struct.ident_t*, i32, i32, i64, i64, i32 (i32, i8*)*)

declare void @__kmpc_set_task_static_id(i8*, i32)

declare i32 @__kmpc_omp_task(%struct.ident_t*, i32, i8*)
